338. 比特位计数
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
进阶:

给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
要求算法的空间复杂度为O(n)。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。

tips:

[移位操作]

<< : 左移运算符，将运算符 左边的对象 向左移动 运算符右边指定的位数（在低位补0）
>> : "有符号"右移运算 符，将运算符 左边的对象 向右移动 运算符右边指定的位数。使用符号扩展机制，也就是说，如果值为正，则在高位补0，如果值为负，则在高位补1
>>> : "无符号"右移运算 符，将运算符 左边的对象 向右移动 运算符右边指定的位数。采用0扩展机制，也就是说，无论值的正负，都在高位补0
short, byte, char 在移位之前首先将数据转换为int

[有符号与无符号]
java没有无符号类型，都是有符号类型的数据类型
    对于数 -1, 即
    int a = -1;
    若
    int b = a >>> 2;
    int c = a >> 2;
    则
    b 的值为 2147483647 (hex: 7fffffff)
    c 的值为 -1 (hex: ffffffff)

    即对a作无符号右移操作时, 高位补0; 对a作有符号右移操作时, 高位补1
    所以b的值是最大正数, c的值和a一样
    
